<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="CMake学习一、CMake概述CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Makefile（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile">
<meta property="og:type" content="article">
<meta property="og:title" content="CMake入门">
<meta property="og:url" content="http://example.com/2025/12/29/c++/cmake/index.html">
<meta property="og:site_name" content="LightningJie 的博客">
<meta property="og:description" content="CMake学习一、CMake概述CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Makefile（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/cmake.png">
<meta property="article:published_time" content="2025-12-29T02:00:00.000Z">
<meta property="article:modified_time" content="2026-01-21T01:41:46.944Z">
<meta property="article:author" content="LightningJie">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/cmake.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>CMake入门</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="LightningJie 的博客" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 8.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/LightningJie">GitHub</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/12/30/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/docker/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/12/28/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Prometheus/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2025/12/29/c++/cmake/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2025/12/29/c++/cmake/&text=CMake入门"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2025/12/29/c++/cmake/&title=CMake入门"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2025/12/29/c++/cmake/&is_video=false&description=CMake入门"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CMake入门&body=Check out this article: http://example.com/2025/12/29/c++/cmake/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2025/12/29/c++/cmake/&title=CMake入门"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2025/12/29/c++/cmake/&title=CMake入门"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2025/12/29/c++/cmake/&title=CMake入门"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2025/12/29/c++/cmake/&title=CMake入门"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2025/12/29/c++/cmake/&name=CMake入门&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2025/12/29/c++/cmake/&t=CMake入门"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CMake%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">CMake学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81CMake%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">一、CMake概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.1.</span> <span class="toc-text">2.1 注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E6%B3%A8%E9%87%8A%E8%A1%8C"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">2.1.1 注释行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E6%B3%A8%E9%87%8A%E5%9D%97"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2.1.2 注释块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8F%AA%E6%9C%89%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.1 只有源文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%85%B1%E5%A4%84%E4%B8%80%E5%AE%A4"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">2.1.1 共处一室</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-VIP-%E5%8C%85%E6%88%BF"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2.1.2 VIP 包房</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%A7%81%E4%BA%BA%E8%AE%A2%E5%88%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">2.2 私人订制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">2.2.1 定义变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8%E7%9A%84C-%E6%A0%87%E5%87%86"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2.2.2 指定使用的C++标准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E6%8C%87%E5%AE%9A%E8%BE%93%E5%87%BA%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">2.2.3 指定输出的路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">2.3 搜索文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E6%96%B9%E5%BC%8F1"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">2.3.1 方式1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E6%96%B9%E5%BC%8F2"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2.3.2 方式2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.5.</span> <span class="toc-text">2.4 包含头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93%E6%88%96%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.1.6.</span> <span class="toc-text">2.5 制作动态库或静态库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">2.5.1 制作静态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">2.5.2 制作动态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E6%8C%87%E5%AE%9A%E8%BE%93%E5%87%BA%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">2.5.3 指定输出的路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%8C%85%E5%90%AB%E5%BA%93%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.7.</span> <span class="toc-text">2.6 包含库文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">2.6.1 链接静态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">2.6.2 链接动态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">2.6.3 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%97%A5%E5%BF%97"><span class="toc-number">1.1.8.</span> <span class="toc-text">2.7 日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.9.</span> <span class="toc-text">2.8 变量操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1-%E8%BF%BD%E5%8A%A0"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">2.8.1 追加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%BB%E9%99%A4"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">2.8.2 字符串移除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.10.</span> <span class="toc-text">2.9 宏定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B5%8C%E5%A5%97%E7%9A%84CMake"><span class="toc-number">1.2.</span> <span class="toc-text">三、嵌套的CMake</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.1 准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">3.1.1 节点关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E6%B7%BB%E5%8A%A0%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">3.1.2 添加子目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2 解决问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">3.2.1 根目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-calc-%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">3.2.2 calc 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-sort-%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3.2.3 sort 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-test1-%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">3.2.4 test1 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-test2-%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">3.2.5 test2 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">3.2.6 构建项目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.2条件判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%9F%BA%E6%9C%AC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">3.2.1 基本表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">3.2.2 逻辑判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.2.3 比较</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-list"><span class="toc-number">2.</span> <span class="toc-text">创建 list</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-list"><span class="toc-number">3.</span> <span class="toc-text">遍历 list</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87list%E7%BB%99%E5%88%97%E8%A1%A8%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">4.</span> <span class="toc-text">通过list给列表添加数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">遍历列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8-1"><span class="toc-number">6.</span> <span class="toc-text">遍历列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SHELL12345678910111213141516-cd-build-cmake-%E2%80%93-%E5%BD%93%E5%89%8D%E9%81%8D%E5%8E%86%E7%9A%84%E5%80%BC%E4%B8%BA-item1-hello-item2-ace%E2%80%93-%E5%BD%93%E5%89%8D%E9%81%8D%E5%8E%86%E7%9A%84%E5%80%BC%E4%B8%BA-item1-world-item2-sabo%E2%80%93-%E5%BD%93%E5%89%8D%E9%81%8D%E5%8E%86%E7%9A%84%E5%80%BC%E4%B8%BA-item1-hello-world-item2-luffy%E2%80%93-%E5%BD%93%E5%89%8D%E9%81%8D%E5%8E%86%E7%9A%84%E5%80%BC%E4%B8%BA-item1-item2-zoro%E2%80%93-%E5%BD%93%E5%89%8D%E9%81%8D%E5%8E%86%E7%9A%84%E5%80%BC%E4%B8%BA-item1-item2-sanji"><span class="toc-number">7.</span> <span class="toc-text">SHELL12345678910111213141516$ cd build&#x2F;$ cmake ..– 当前遍历的值为: item1 &#x3D; hello, item2&#x3D;ace– 当前遍历的值为: item1 &#x3D; world, item2&#x3D;sabo– 当前遍历的值为: item1 &#x3D; hello world, item2&#x3D;luffy– 当前遍历的值为: item1 &#x3D; , item2&#x3D;zoro– 当前遍历的值为: item1 &#x3D; , item2&#x3D;sanji</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8-NAME"><span class="toc-number">8.</span> <span class="toc-text">创建一个列表 NAME</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%97%E5%88%B0%E5%88%97%E8%A1%A8%E9%95%BF%E5%BA%A6"><span class="toc-number">9.</span> <span class="toc-text">得到列表长度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">10.</span> <span class="toc-text">循环</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        CMake入门
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">LightningJie</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-12-29T02:00:00.000Z" class="dt-published" itemprop="datePublished">2025-12-29</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/c/">c++</a> › <a class="category-link" href="/categories/c/%E5%9F%BA%E7%A1%80/">基础</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="CMake学习"><a href="#CMake学习" class="headerlink" title="CMake学习"></a>CMake学习</h1><h2 id="一、CMake概述"><a href="#一、CMake概述" class="headerlink" title="一、CMake概述"></a>一、CMake概述</h2><p>CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Makefile（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile 的工作量比较大，解决依赖关系时也容易出错。</p>
<p>而 CMake 恰好能解决上述问题， 其允许开发者指定整个工程的编译流程，在根据编译平台，自动生成本地化的Makefile和工程文件，最后用户只需make编译即可，所以可以<strong>把CMake看成一款自动生成 Makefile的工具</strong>，其编译流程如下图：</p>
<p><img src="/../../images/cmake.png" alt="anzhiyu"></p>
<ul>
<li>蓝色虚线表示使用makefile构建项目的过程</li>
<li>红色实线表示使用cmake构建项目的过程</li>
</ul>
<p>CMake的优点：</p>
<ul>
<li>跨平台</li>
<li>能够管理大型项目</li>
<li>简化编译构建过程和编译过程</li>
<li>可扩展：可以为 cmake 编写特定功能的模块，扩充 cmake 功能</li>
</ul>
<ol start="2">
<li>CMake的使用<br>CMake支持大写、小写、混合大小写的命令。如果在编写CMakeLists.txt文件时使用的工具有对应的命令提示，那么大小写随缘即可，不要太过在意。</li>
</ol>
<h3 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h3><h4 id="2-1-1-注释行"><a href="#2-1-1-注释行" class="headerlink" title="2.1.1 注释行"></a>2.1.1 注释行</h4><p>CMake 使用 # 进行行注释，可以放在任何位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这是一个 CMakeLists.txt 文件</span><br><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br></pre></td></tr></table></figure>

<p>cmake_minimum_required(VERSION 3.0.0)</p>
<h4 id="2-1-2-注释块"><a href="#2-1-2-注释块" class="headerlink" title="2.1.2 注释块"></a>2.1.2 注释块</h4><p>CMake 使用 #[[ ]] 形式进行块注释。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[[ 这是一个 CMakeLists.txt 文件。</span></span><br><span class="line"><span class="comment">这是一个 CMakeLists.txt 文件</span></span><br><span class="line"><span class="comment">这是一个 CMakeLists.txt 文件]]</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-只有源文件"><a href="#2-1-只有源文件" class="headerlink" title="2.1 只有源文件"></a>2.1 只有源文件</h3><h4 id="2-1-1-共处一室"><a href="#2-1-1-共处一室" class="headerlink" title="2.1.1 共处一室"></a>2.1.1 共处一室</h4><p>准备工作，为了方便测试，在我本地电脑准备了这么几个测试文件</p>
<p><strong>add.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sub.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你好</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mult.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>div.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>head.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEAD_H</span></span><br><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 乘法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 除法</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, <span class="built_in">add</span>(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a - b = %d\n&quot;</span>, <span class="built_in">subtract</span>(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a * b = %d\n&quot;</span>, <span class="built_in">multiply</span>(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a / b = %f\n&quot;</span>, <span class="built_in">divide</span>(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述文件的目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>

<p>添加 CMakeLists.txt 文件</p>
<p>在上述源文件所在目录下添加一个新文件 CMakeLists.txt，文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">add_executable</span>(app add.c div.c main.c mult.c sub.c)</span><br></pre></td></tr></table></figure>

<p>接下来依次介绍一下在 CMakeLists.txt 文件中添加的三个命令:</p>
<ul>
<li>cmake_minimum_required：指定使用的 cmake 的最低版本</li>
</ul>
<p>可选，非必须，如果不加可能会有警告</p>
<ul>
<li>project：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PROJECT 指令的语法是：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt; [&lt;language-name&gt;...])</span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt;</span><br><span class="line">       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</span><br><span class="line">       [DESCRIPTION &lt;<span class="keyword">project</span>-description-<span class="keyword">string</span>&gt;]</span><br><span class="line">       [HOMEPAGE_URL &lt;url-<span class="keyword">string</span>&gt;]</span><br><span class="line">       [LANGUAGES &lt;language-name&gt;...])</span><br></pre></td></tr></table></figure>



<ul>
<li>add_executable：定义工程会生成一个可执行程序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_executable(可执行程序名 源文件名称)</span><br></pre></td></tr></table></figure>

<p>这里的可执行程序名和project中的项目名没有任何关系</p>
<p>源文件名可以是一个也可以是多个，如有多个可用空格或<code>;</code>间隔</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 样式1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app add.c div.c main.c mult.c sub.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 样式2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app add.c;div.c;main.c;mult.c;sub.c)</span><br></pre></td></tr></table></figure>

<ul>
<li>执行CMake 命令</li>
</ul>
<p>万事俱备只欠东风，将 CMakeLists.txt 文件编辑好之后，就可以执行 cmake命令了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cmake 命令原型</span><br><span class="line"></span><br><span class="line">$ cmake CMakeLists.txt文件所在路径</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br><span class="line"></span><br><span class="line">0 directories, 7 files</span><br></pre></td></tr></table></figure>


<p>当执行cmake命令之后，CMakeLists.txt 中的命令就会被执行，所以一定要注意给cmake 命令指定路径的时候一定不能出错。</p>
<p>执行命令之后，看一下源文件所在目录中是否多了一些文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── CMakeCache.txt         # new add file</span><br><span class="line">├── CMakeFiles             # new add dir</span><br><span class="line">├── cmake_install.cmake    # new add file</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── Makefile               # new add file</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>

<p>我们可以看到在对应的目录下生成了一个makefile文件，此时再执行make命令，就可以对项目进行构建得到所需的可执行程序了。<br>$ make<br>Scanning dependencies of target app<br>[ 16%] Building C object CMakeFiles&#x2F;app.dir&#x2F;add.c.o<br>[ 33%] Building C object CMakeFiles&#x2F;app.dir&#x2F;div.c.o<br>[ 50%] Building C object CMakeFiles&#x2F;app.dir&#x2F;main.c.o<br>[ 66%] Building C object CMakeFiles&#x2F;app.dir&#x2F;mult.c.o<br>[ 83%] Building C object CMakeFiles&#x2F;app.dir&#x2F;sub.c.o<br>[100%] Linking C executable app<br>[100%] Built target app</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可执行程序是否已经生成</span></span><br><span class="line"></span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── app					<span class="comment"># 生成的可执行程序</span></span><br><span class="line">├── CMakeCache.txt</span><br><span class="line">├── CMakeFiles</span><br><span class="line">├── cmake_install.cmake</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br><span class="line">├── Makefile</span><br><span class="line">├── mult.c</span><br><span class="line">└── sub.c</span><br></pre></td></tr></table></figure>

<p>最终可执行程序app就被编译出来了（这个名字是在CMakeLists.txt中指定的）。</p>
<h4 id="2-1-2-VIP-包房"><a href="#2-1-2-VIP-包房" class="headerlink" title="2.1.2 VIP 包房"></a>2.1.2 VIP 包房</h4><p>通过上面的例子可以看出，如果在CMakeLists.txt文件所在目录执行了cmake命令之后就会生成一些目录和文件（包括 makefile 文件），如果再基于makefile文件执行make命令，程序在编译过程中还会生成一些中间文件和一个可执行文件，这样会导致整个项目目录看起来很混乱，不太容易管理和维护，此时我们就可以把生成的这些与项目源码无关的文件统一放到一个对应的目录里边，比如将这个目录命名为build:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/Linux/build</span><br></pre></td></tr></table></figure>

<p>现在cmake命令是在build目录中执行的，但是CMakeLists.txt文件是build目录的上一级目录中，所以cmake 命令后指定的路径为..，即当前目录的上一级目录。</p>
<p>当命令执行完毕之后，在build目录中会生成一个makefile文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree build -L 1</span><br><span class="line">build</span><br><span class="line">├── CMakeCache.txt</span><br><span class="line">├── CMakeFiles</span><br><span class="line">├── cmake_install.cmake</span><br><span class="line">└── Makefile</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure>

<p>这样就可以在build目录中执行make命令编译项目，生成的相关文件自然也就被存储到build目录中了。这样通过cmake和make生成的所有文件就全部和项目源文件隔离开了，各回各家，各找各妈。</p>
<h3 id="2-2-私人订制"><a href="#2-2-私人订制" class="headerlink" title="2.2 私人订制"></a>2.2 私人订制</h3><h4 id="2-2-1-定义变量"><a href="#2-2-1-定义变量" class="headerlink" title="2.2.1 定义变量"></a>2.2.1 定义变量</h4><p>在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用set。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SET 指令的语法是：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [] 中的参数为可选项, 如不需要可以不写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br></pre></td></tr></table></figure>

<p>VAR：变量名<br>VALUE：变量值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 方式1: 各个源文件之间使用空格间隔</span><br><span class="line"></span><br><span class="line"># set(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)</span><br><span class="line"></span><br><span class="line"># 方式2: 各个源文件之间使用分号 ; 间隔</span><br><span class="line"></span><br><span class="line">set(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)</span><br><span class="line">add_executable(app  $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-指定使用的C-标准"><a href="#2-2-2-指定使用的C-标准" class="headerlink" title="2.2.2 指定使用的C++标准"></a>2.2.2 指定使用的C++标准</h4><p>在编写C++程序的时候，可能会用到C++11、C++14、C++17、C++20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.cpp -std=c++11 -o app</span><br></pre></td></tr></table></figure>

<p>上面的例子中通过参数-std&#x3D;c++11指定出要使用c++11标准编译程序，C++标准对应有一宏叫做DCMAKE_CXX_STANDARD。在CMake中想要指定C++标准有两种方式：</p>
<p>在 CMakeLists.txt 中通过 set 命令指定</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加-std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment">#增加-std=c++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="comment">#增加-std=c++17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br></pre></td></tr></table></figure>

<p>在执行 cmake 命令的时候指定出这个宏的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加-std=c++11</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11</span><br><span class="line"><span class="comment">#增加-std=c++14</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14</span><br><span class="line"><span class="comment">#增加-std=c++17</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17</span><br></pre></td></tr></table></figure>

<p>在上面例子中 CMake 后的路径需要根据实际情况酌情修改。</p>
<h4 id="2-2-3-指定输出的路径"><a href="#2-2-3-指定输出的路径" class="headerlink" title="2.2.3 指定输出的路径"></a>2.2.3 指定输出的路径</h4><p>在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令进行设置:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(HOME /home/robin/Linux/Sort)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行：定义一个变量用于存储一个绝对路径</p>
</li>
<li><p>第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏</p>
</li>
</ul>
<p>如果这个路径中的子目录不存在，会自动生成，无需自己手动创建<br>由于可执行程序是基于 cmake 命令生成的 makefile 文件然后再执行 make 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径 .&#x2F;xxx&#x2F;xxx，那么这个路径中的 .&#x2F; 对应的就是 makefile 文件所在的那个目录。</p>
<h3 id="2-3-搜索文件"><a href="#2-3-搜索文件" class="headerlink" title="2.3 搜索文件"></a>2.3 搜索文件</h3><p>如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用aux_source_directory命令或者file命令。</p>
<h4 id="2-3-1-方式1"><a href="#2-3-1-方式1" class="headerlink" title="2.3.1 方式1"></a>2.3.1 方式1</h4><p>在 CMake 中使用aux_source_directory 命令可以查找某个路径下的所有源文件，命令格式为：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt; dir &gt; &lt; variable &gt;)</span><br></pre></td></tr></table></figure>

<p>dir：要搜索的目录<br>variable：将从dir目录下搜索到的源文件列表存储到该变量中</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><code>${CMAKE_CURRENT_SOURCE_DIR}</code> 是一个内置变量，它代表的是<strong>当前正在处理的 CMakeLists.txt 文件所在的目录路径</strong></p>
<h4 id="2-3-2-方式2"><a href="#2-3-2-方式2" class="headerlink" title="2.3.2 方式2"></a>2.3.2 方式2</h4><p>如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦了。所以，在CMake中为我们提供了搜索文件的命令，他就是file（当然，除了搜索以外通过 file 还可以做其他事情）。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br></pre></td></tr></table></figure>

<ul>
<li>GLOB: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</li>
<li>GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</li>
</ul>
<p>搜索当前目录的src目录下所有的源文件，并存储到变量中</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure>

<p>CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。</p>
<p>关于要搜索的文件路径和类型可加双引号，也可不加:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB MAIN_HEAD &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.h&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-包含头文件"><a href="#2-4-包含头文件" class="headerlink" title="2.4 包含头文件"></a>2.4 包含头文件</h3><p>引入自定义头文件一般是<code>include “head.h”</code> 但是这个是当前文件目录下的<code>head.h</code>文件，如果将源文件和头文件分开就找不到了head.h文件了这时候可以采用相对路径  <code>#include“head.h”</code></p>
<p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是include_directories:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_directories(headpath)</span><br></pre></td></tr></table></figure>

<p>举例说明，有源文件若干，其目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">└── src</span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br><span class="line"></span><br><span class="line">3 directories, 7 files</span><br></pre></td></tr></table></figure>

<p>CMakeLists.txt文件内容如下:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(HOME /home/robin/Linux/calc)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin/)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>其中，第六行指定就是头文件的路径，<strong>PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录</strong>，一般是工程的根目录。</p>
<h3 id="2-5-制作动态库或静态库"><a href="#2-5-制作动态库或静态库" class="headerlink" title="2.5 制作动态库或静态库"></a>2.5 制作动态库或静态库</h3><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p>
<h4 id="2-5-1-制作静态库"><a href="#2-5-1-制作静态库" class="headerlink" title="2.5.1 制作静态库"></a>2.5.1 制作静态库</h4><p>静态库是编译时被完整复制到最终可执行文件中的代码集合，&#x3D;&#x3D;静态库没有可执行权限&#x3D;&#x3D;。</p>
<p>在cmake中，如果要制作静态库，需要使用的命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名称 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br></pre></td></tr></table></figure>

<p>在Linux中，静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p>
<p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p>
<p>下面有一个目录，需要将src目录中的源文件编译成静态库，然后再使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include           <span class="comment"># 头文件目录</span></span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp          <span class="comment"># 用于测试的源文件</span></span><br><span class="line">└── src               <span class="comment"># 源文件目录</span></span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br></pre></td></tr></table></figure>

<p>根据上面的目录结构，可以这样编写CMakeLists.txt文件:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样最终就会生成对应的静态库文件libcalc.a。</p>
<h4 id="2-5-2-制作动态库"><a href="#2-5-2-制作动态库" class="headerlink" title="2.5.2 制作动态库"></a>2.5.2 制作动态库</h4><p>动态库是在程序<strong>运行时</strong>被加载到内存中供程序调用的代码集合，不会被复制到可执行文件中，&#x3D;&#x3D;动态库具有可执行权限&#x3D;&#x3D;。</p>
<p>在cmake中，如果要制作动态库，需要使用的命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名称 SHARED 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br></pre></td></tr></table></figure>

<p>在Linux中，动态库名字分为三部分：lib+库名字+.so，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p>
<p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p>
<p>根据上面的目录结构，可以这样编写CMakeLists.txt文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)</span><br><span class="line">add_library(calc SHARED $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>

<p>这样最终就会生成对应的动态库文件libcalc.so。</p>
<p>&#x3D;&#x3D;无论是静态库还是动态库，开发者在发布时都要给用户两个文件 一个是头文件夹 一个是lib库文件。&#x3D;&#x3D;</p>
<h4 id="2-5-3-指定输出的路径"><a href="#2-5-3-指定输出的路径" class="headerlink" title="2.5.3 指定输出的路径"></a>2.5.3 指定输出的路径</h4><p><strong>方式1 - 适用于动态库</strong><br>对于生成的库文件来说和可执行程序一样都可以指定输出路径。由于在Linux下生成的动态库默认是有执行权限的，所以可以按照生成可执行程序的方式去指定它生成的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)</span><br><span class="line"></span><br><span class="line"># 设置动态库生成路径</span><br><span class="line"></span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line">add_library(calc SHARED $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>

<p>对于这种方式来说，其实就是通过set命令给EXECUTABLE_OUTPUT_PATH宏设置了一个路径，这个路径就是可执行文件生成的路径。</p>
<p><strong>方式2 - 都适用</strong><br>由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用EXECUTABLE_OUTPUT_PATH宏了，而应该使用LIBRARY_OUTPUT_PATH，这个宏对应静态库文件和动态库文件都适用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)</span><br><span class="line"></span><br><span class="line"># 设置动态库/静态库生成路径</span><br><span class="line"></span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line"># 生成动态库</span><br><span class="line"></span><br><span class="line">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line"># 生成静态库</span><br><span class="line"></span><br><span class="line">add_library(calc STATIC $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-6-包含库文件"><a href="#2-6-包含库文件" class="headerlink" title="2.6 包含库文件"></a>2.6 包含库文件</h3><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p>
<h4 id="2-6-1-链接静态库"><a href="#2-6-1-链接静态库" class="headerlink" title="2.6.1 链接静态库"></a>2.6.1 链接静态库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure>

<p>现在我们把上面src目录中的add.cpp、div.cpp、mult.cpp、sub.cpp编译成一个静态库文件libcalc.a。通过命令制作并使用静态链接库</p>
<p>测试目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tree </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br></pre></td></tr></table></figure>


<p>在cmake中，<strong>链接静态库</strong>的命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br></pre></td></tr></table></figure>

<p>用于设置全局链接库，这些库会链接到之后定义的所有目标上。</p>
<ul>
<li>参数1：指定出要链接的静态库的名字</li>
</ul>
<p>可以是全名 libxxx.a<br>也可以是掐头（lib）去尾（.a）之后的名字 xxx</p>
<ul>
<li>参数2-N：要链接的其它静态库的名字</li>
</ul>
<p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure>

<p>这样，修改之后的CMakeLists.txt文件内容如下:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含静态库路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>


<p>添加了第8行的代码，就可以根据参数指定的路径找到这个静态库了。</p>
<h4 id="2-6-2-链接动态库"><a href="#2-6-2-链接动态库" class="headerlink" title="2.6.2 链接动态库"></a>2.6.2 链接动态库</h4><p>在程序编写过程中，除了在项目中引入静态库，好多时候也会使用一些标准的或者第三方提供的一些动态库，关于动态库的制作、使用以及在内存中的加载方式和静态库都是不同的，在此不再过多赘述，如有疑惑请参考Linux 静态库和动态库</p>
<p>在cmake中链接动态库的命令如下:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    &lt;<span class="keyword">target</span>&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure>

<p>用于指定一个目标（如可执行文件或库）在编译时需要链接哪些库。它支持指定库的名称、路径以及链接库的顺序。</p>
<ul>
<li>target：指定要加载的库的文件的名字</li>
</ul>
<p>该文件可能是一个源文件<br>该文件可能是一个动态库&#x2F;静态库文件<br>该文件可能是一个可执行文件</p>
<ul>
<li>PRIVATE|PUBLIC|INTERFACE：动态库的访问权限，默认为PUBLIC</li>
</ul>
<p>如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的 PUBLIC 即可。</p>
<p>动态库的链接具有传递性，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(A B C)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(D A)</span><br></pre></td></tr></table></figure>

<p>PUBLIC：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。<br>PRIVATE：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库<br>INTERFACE：在interface后面引入的库不会被链接到前面的target中，只会导出符号。<br><strong>链接系统动态库</strong></p>
<p>动态库的链接和静态库是完全不同的：</p>
<p>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。<br>动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存<br>因此，在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加并指定最终生成的可执行程序名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行程序要链接的动态库名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread)</span><br></pre></td></tr></table></figure>


<p>在target_link_libraries(app pthread)中：</p>
<p>app: 对应的是最终生成的可执行程序的名字<br>pthread：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为libpthread.so，在指定的时候一般会掐头（lib）去尾（.so）。<br>链接第三方动态库<br>现在，自己生成了一个动态库，对应的目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tree </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h            <span class="comment"># 动态库对应的头文件</span></span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.so        <span class="comment"># 自己制作的动态库文件</span></span><br><span class="line">└── main.cpp              <span class="comment"># 测试用的源文件</span></span><br><span class="line"></span><br><span class="line">3 directories, 4 files</span><br></pre></td></tr></table></figure>


<p>假设在测试文件main.cpp中既使用了自己制作的动态库libcalc.so又使用了系统提供的线程库，此时CMakeLists.txt文件可以这样写：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></table></figure>

<p>在第六行中，pthread、calc都是可执行程序app要链接的动态库的名字。当可执行程序app生成之后并执行该文件，会提示有如下错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./app </span><br><span class="line">./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>这是因为可执行程序启动之后，去加载calc这个动态库，但是不知道这个动态库被放到了什么位置解决动态库无法加载的问题，所以就加载失败了，在 CMake 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令：<br>link_directories(path)<br>所以修改之后的CMakeLists.txt文件应该是这样的：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定源文件或者动态库对应的头文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要链接的动态库的路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加并生成一个可执行程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要链接的动态库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></table></figure>


<p>通过link_directories指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。</p>
<h4 id="2-6-3-总结"><a href="#2-6-3-总结" class="headerlink" title="2.6.3 总结"></a>2.6.3 总结</h4><p>温馨提示：target_link_libraries 和  link_libraries 是 CMake 中用于链接库的两个命令，都可以用于链接动态库和静态库，但它们的使用场景和功能有所不同。下面是关于二者的总结：</p>
<p><strong>target_link_libraries</strong></p>
<p>功能: target_link_libraries 用于指定一个目标（如可执行文件或库）在编译时需要链接哪些库。它支持指定库的名称、路径以及链接库的顺序。</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(target_name [item1 [item2 [...]]]</span><br><span class="line">                      [&lt;debug|optimized|general&gt; &lt;lib1&gt; [&lt;lib2&gt; [...]]])</span><br></pre></td></tr></table></figure>

<p>优点:</p>
<p>更精确地控制目标的链接库。<br>可以指定库的不同链接条件（如调试版本、发布版本）。<br>支持多个目标和多个库之间的复杂关系。<br>更加灵活和易于维护，特别是在大型项目中。<br>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable(my_executable main.cpp)</span><br><span class="line">target_link_libraries(my_executable PRIVATE my_dynamic_library)</span><br></pre></td></tr></table></figure>

<p><strong>link_libraries</strong></p>
<p>功能: link_libraries 用于设置全局链接库，这些库会链接到之后定义的所有目标上。它会影响所有的目标，适用于全局设置，但不如 target_link_libraries 精确。</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link_libraries(lib1 lib2 [...])</span><br></pre></td></tr></table></figure>

<p>缺点:</p>
<p>缺乏针对具体目标的控制，不适合复杂的项目结构。<br>容易导致意外的依赖关系，因为它对所有目标都生效。<br>一旦设置，全局影响可能导致难以追踪的链接问题。<br>示例:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(my_static_library)</span><br><span class="line"><span class="keyword">add_executable</span>(my_executable main.cpp)</span><br></pre></td></tr></table></figure>

<p>总结</p>
<p>target_link_libraries 是更推荐的方式，因为它允许更精确的控制和管理链接库的依赖，特别是在大型项目中，它能够避免全局设置可能带来的问题。<br>link_libraries 虽然简单，但在复杂的项目中可能会导致意外的问题，通常适用于简单的项目或临时设置。<br>建议在 CMake 项目中优先使用 target_link_libraries。</p>
<h3 id="2-7-日志"><a href="#2-7-日志" class="headerlink" title="2.7 日志"></a>2.7 日志</h3><p>在CMake中可以用用户显示一条消息，该命令的名字为message：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure>

<ul>
<li>(无) ：重要消息</li>
<li>STATUS ：非重要消息</li>
<li>WARNING：CMake 警告, 会继续执行</li>
<li>AUTHOR_WARNING：CMake 警告 (dev), 会继续执行</li>
<li>SEND_ERROR：CMake 错误, 继续执行，但是会跳过生成的步骤</li>
<li>FATAL_ERROR：CMake 错误, 终止所有处理过程</li>
</ul>
<p>CMake的命令行工具会在stdout上显示STATUS消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。</p>
<p>CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出一般日志信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-8-变量操作"><a href="#2-8-变量操作" class="headerlink" title="2.8 变量操作"></a>2.8 变量操作</h3><h4 id="2-8-1-追加"><a href="#2-8-1-追加" class="headerlink" title="2.8.1 追加"></a>2.8.1 追加</h4><p>有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过file命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用set命令也可以使用list命令。</p>
<p>使用set拼接<br>如果使用set进行字符串拼接，对应的命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(变量名1 $&#123;变量名1&#125; $&#123;变量名2&#125; ...)</span><br></pre></td></tr></table></figure>

<p>关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">set(TEMP &quot;hello,world&quot;)</span><br><span class="line">file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/src1/*.cpp)</span><br><span class="line">file(GLOB SRC_2 $&#123;PROJECT_SOURCE_DIR&#125;/src2/*.cpp)</span><br><span class="line"></span><br><span class="line"># 追加(拼接)</span><br><span class="line"></span><br><span class="line">set(SRC_1 $&#123;SRC_1&#125; $&#123;SRC_2&#125; $&#123;TEMP&#125;)</span><br><span class="line">message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>使用list拼接<br>如果使用list进行字符串拼接，对应的命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(APPEND &lt;list&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>


<p>list命令的功能比set要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，APPEND表示进行数据追加，后边的参数和set就一样了。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(APPEND SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span> <span class="variable">$&#123;TEMP&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>


<p>在CMake中，使用set命令可以创建一个list。<strong>一个在list内部是一个由分号;分割的一组字符串</strong>。例如，set(var a b c d e)命令将会创建一个list:a;b;c;d;e，但是最终打印变量值的时候得到的是abcde。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/set(tmp1 a;b;c;d;e)</span><br><span class="line">set(tmp2 a b c d e)</span><br><span class="line">message($&#123;tmp1&#125;)</span><br><span class="line">message($&#123;tmp2&#125;)</span><br></pre></td></tr></table></figure>

<p>输出的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure>

<h4 id="2-8-2-字符串移除"><a href="#2-8-2-字符串移除" class="headerlink" title="2.8.2 字符串移除"></a>2.8.2 字符串移除</h4><p>我们在通过file搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件并不是我们所需要的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br><span class="line"></span><br><span class="line">0 directories, 5 files</span><br></pre></td></tr></table></figure>

<p>在当前这么目录有五个源文件，其中main.cpp是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要add.cpp、div.cp、mult.cpp、sub.cpp这四个源文件就可以了。此时，就需要将main.cpp从搜索到的数据中剔除出去，想要实现这个功能，也可以使用list</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure>

<p>通过上面的命令原型可以看到删除和追加数据类似，只不过是第一个参数变成了REMOVE_ITEM。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除前日志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除后日志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>


<p>可以看到，在第8行把将要移除的文件的名字指定给list就可以了。但是一定要注意通过 file 命令搜索源文件的时候得到的是文件的绝对路径（在list中每个文件对应的路径都是一个item，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以，否是移除操作不会成功。</p>
<p>关于list命令还有其它功能，但是并不常用，在此就不一一进行举例介绍了。</p>
<p>获取 list 的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(LENGTH &lt;list&gt; &lt;output variable&gt;)</span><br></pre></td></tr></table></figure>

<p>LENGTH：子命令LENGTH用于读取列表长度</p>
<ul>
<li><list>：当前操作的列表</li>
<li><output variable>：新创建的变量，用于存储列表的长度。</li>
</ul>
<p>读取列表中指定索引的的元素，可以指定多个索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(GET &lt;list&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)</span><br></pre></td></tr></table></figure>

<p>-<br>  <list>：当前操作的列表</p>
<ul>
<li><element index>：列表元素的索引</li>
</ul>
<p>从0开始编号，索引0的元素为列表中的第一个元素；<br>索引也可以是负数，-1表示列表的最后一个元素，-2表示列表倒数第二个元素，以此类推<br>当索引（不管是正还是负）超过列表的长度，运行会报错<br><output variable>：新创建的变量，存储指定索引元素的返回结果，也是一个列表。<br>将列表中的元素用连接符（字符串）连接起来组成一个字符串</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (JOIN &lt;<span class="keyword">list</span>&gt; &lt;glue&gt; &lt;output variable&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><list>：当前操作的列表</li>
<li><glue>：指定的连接符（字符串）</li>
<li><output variable>：新创建的变量，存储返回的字符串</li>
</ul>
<p><strong>查找列表是否存在指定的元素，若果未找到，返回-1</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(FIND &lt;<span class="keyword">list</span>&gt; &lt;value&gt; &lt;output variable&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><list>：当前操作的列表</li>
<li><value>：需要再列表中搜索的元素</li>
<li><output variable>：新创建的变量</li>
</ul>
<p>如果列表<list>中存在<value>，那么返回<value>在列表中的索引<br>如果未找到则返回-1。<br><strong>将元素追加到列表中</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>

<p><strong>在list中指定的位置插入若干元素</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(INSERT &lt;<span class="keyword">list</span>&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>

<p><strong>将元素插入到列表的0索引位置</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (PREPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>

<p><strong>将列表中最后元素移除</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (POP_BACK &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br></pre></td></tr></table></figure>

<p><strong>将列表中第一个元素移除</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (POP_FRONT &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br></pre></td></tr></table></figure>

<p><strong>将指定的元素从列表中移除</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure>

<p><strong>将指定索引的元素从列表中移除</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (REMOVE_AT &lt;<span class="keyword">list</span>&gt; &lt;index&gt; [&lt;index&gt; ...])</span><br></pre></td></tr></table></figure>

<p><strong>移除列表中的重复元素</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (REMOVE_DUPLICATES &lt;<span class="keyword">list</span>&gt;)</span><br></pre></td></tr></table></figure>

<p><strong>列表翻转</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(REVERSE &lt;<span class="keyword">list</span>&gt;)</span><br></pre></td></tr></table></figure>

<p><strong>列表排序</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (SORT &lt;<span class="keyword">list</span>&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])</span><br></pre></td></tr></table></figure>

<ul>
<li>COMPARE：指定排序方法。有如下几种值可选：</li>
<li>STRING:按照字母顺序进行排序，为默认的排序方法</li>
<li>FILE_BASENAME：如果是一系列路径名，会使用basename进行排序</li>
<li>NATURAL：使用自然数顺序排序</li>
<li>CASE：指明是否大小写敏感。有如下几种值可选：</li>
<li>SENSITIVE: 按照大小写敏感的方式进行排序，为默认值</li>
<li>INSENSITIVE：按照大小写不敏感方式进行排序</li>
<li>ORDER：指明排序的顺序。有如下几种值可选：</li>
<li>ASCENDING:按照升序排列，为默认值</li>
<li>DESCENDING：按照降序排列</li>
</ul>
<h3 id="2-9-宏定义"><a href="#2-9-宏定义" class="headerlink" title="2.9 宏定义"></a>2.9 宏定义</h3><p>在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏来控制这些代码是否生效，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER  3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是一个程序猿, 我不会爬树...\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;NUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, GCC!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在程序的第七行对DEBUG宏进行了判断，如果该宏被定义了，那么第八行就会进行日志输出，如果没有定义这个宏，第八行就相当于被注释掉了，因此最终无法看到日志输入出（上述代码中并没有定义这个宏）。</p>
<p><strong>为了让测试更灵活，我们可以不在代码中定义这个宏</strong>，而是在测试的时候去把它定义出来，其中一种方式就是在gcc&#x2F;g++命令中去指定，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -DDEBUG -o app</span><br></pre></td></tr></table></figure>

<p>在gcc&#x2F;g++命令中通过参数 -D指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为DEBUG。</p>
<p>在CMake中我们也可以做类似的事情，对应的命令叫做add_definitions:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_definitions(-D宏名称)</span><br></pre></td></tr></table></figure>

<p>针对于上面的源文件编写一个CMakeLists.txt，内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义 DEBUG 宏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_definitions</span>(-DDEBUG)</span><br><span class="line"><span class="keyword">add_executable</span>(app ./<span class="keyword">test</span>.c)</span><br></pre></td></tr></table></figure>


<p>通过这种方式，上述代码中的第八行日志就能够被输出出来了。</p>
<p>预定义宏<br>下面的列表中为大家整理了一些CMake中常用的宏：</p>
<p>宏	                                       功能<br>PROJECT_SOURCE_DIR	使用cmake命令后紧跟的目录，一般是工程的根目录<br>PROJECT_BINARY_DIR	执行cmake命令的目录<br>CMAKE_CURRENT_SOURCE_DIR	当前处理的CMakeLists.txt所在的路径<br>CMAKE_CURRENT_BINARY_DIR	target 编译目录<br>EXECUTABLE_OUTPUT_PATH	重新定义目标二进制可执行文件的存放位置<br>LIBRARY_OUTPUT_PATH	重新定义目标链接库文件的存放位置<br>PROJECT_NAME	返回通过PROJECT指令定义的项目名称<br>CMAKE_BINARY_DIR	项目实际构建路径，假设在build目录进行的构建，那么得到的就是这个目录的路径</p>
<h2 id="三、嵌套的CMake"><a href="#三、嵌套的CMake" class="headerlink" title="三、嵌套的CMake"></a>三、嵌套的CMake</h2><p>如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个CMakeLists.txt，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个CMakeLists.txt文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。</p>
<p>先来看一下下面的这个的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── calc</span><br><span class="line">│   ├── add.cpp</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── div.cpp</span><br><span class="line">│   ├── mult.cpp</span><br><span class="line">│   └── sub.cpp</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   ├── calc.h</span><br><span class="line">│   └── sort.h</span><br><span class="line">├── sort</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── insert.cpp</span><br><span class="line">│   └── select.cpp</span><br><span class="line">├── test1</span><br><span class="line">│   ├── calc.cpp</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── test2</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── sort.cpp</span><br><span class="line"></span><br><span class="line">6 directories, 15 files</span><br></pre></td></tr></table></figure>

<p>include 目录：头文件目录<br>calc 目录：目录中的四个源文件对应的加、减、乘、除算法<br>对应的头文件是include中的calc.h<br>sort 目录 ：目录中的两个源文件对应的是插入排序和选择排序算法<br>对应的头文件是include中的sort.h<br>test1 目录：测试目录，对加、减、乘、除算法进行测试<br>test2 目录：测试目录，对排序算法进行测试<br>可以看到各个源文件目录所需要的CMakeLists.txt文件现在已经添加完毕了。接下来庖丁解牛，我们依次分析一下各个文件中需要添加的内容。</p>
<h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1 准备工作"></a>3.1 准备工作</h3><h4 id="3-1-1-节点关系"><a href="#3-1-1-节点关系" class="headerlink" title="3.1.1 节点关系"></a>3.1.1 节点关系</h4><p>众所周知，Linux的目录是树状结构，所以嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。因此，我们需要了解一些关于 CMakeLists.txt 文件变量作用域的一些信息：</p>
<p>根节点CMakeLists.txt中的变量全局有效<br>父节点CMakeLists.txt中的变量可以在子节点中使用<br>子节点CMakeLists.txt中的变量只能在当前节点中使用</p>
<h4 id="3-1-2-添加子目录"><a href="#3-1-2-添加子目录" class="headerlink" title="3.1.2 添加子目录"></a>3.1.2 添加子目录</h4><p>接下来我们还需要知道在 CMake 中父子节点之间的关系是如何建立的，这里需要用到一个 CMake 命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>

<ul>
<li>source_dir：指定了CMakeLists.txt源文件和代码文件的位置，其实就是指定子目录</li>
<li>binary_dir：指定了输出文件的路径，一般不需要指定，忽略即可。</li>
<li>EXCLUDE_FROM_ALL：在子路径下的目标默认不会被包含到父路径的ALL目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。</li>
</ul>
<p>通过这种方式CMakeLists.txt文件之间的父子关系就被构建出来了。</p>
<h3 id="3-2-解决问题"><a href="#3-2-解决问题" class="headerlink" title="3.2 解决问题"></a>3.2 解决问题</h3><p>在上面的目录中我们要做如下事情：</p>
<p>通过 test1 目录中的测试文件进行计算器相关的测试<br>通过 test2 目录中的测试文件进行排序相关的测试<br>现在相当于是要进行模块化测试，对于calc和sort目录中的源文件来说，可以将它们先编译成库文件（可以是静态库也可以是动态库）然后在提供给测试文件使用即可。库文件的本质其实还是代码，只不过是从文本格式变成了二进制格式。</p>
<h4 id="3-2-1-根目录"><a href="#3-2-1-根目录" class="headerlink" title="3.2.1 根目录"></a>3.2.1 根目录</h4><p>根目录中的 CMakeLists.txt文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态库生成的路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(LIB_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试程序生成的路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(EXEC_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(HEAD_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态库的名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CALC_LIB calc)</span><br><span class="line"><span class="keyword">set</span>(SORT_LIB sort)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行程序的名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(APP_NAME_1 test1)</span><br><span class="line"><span class="keyword">set</span>(APP_NAME_2 test2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(calc)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(sort)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(test1)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(test2)</span><br></pre></td></tr></table></figure>


<p>在根节点对应的文件中主要做了两件事情：定义全局变量和添加子目录。</p>
<p>定义的全局变量主要是给子节点使用，目的是为了提高子节点中的CMakeLists.txt文件的可读性和可维护性，避免冗余并降低出差的概率。<br>一共添加了四个子目录，每个子目录中都有一个CMakeLists.txt文件，这样它们的父子关系就被确定下来了。</p>
<h4 id="3-2-2-calc-目录"><a href="#3-2-2-calc-目录" class="headerlink" title="3.2.2 calc 目录"></a>3.2.2 calc 目录</h4><p>calc 目录中的 CMakeLists.txt文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCLIB)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;CALC_LIB&#125;</span> STATIC <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>第3行aux_source_directory：搜索当前目录（calc目录）下的所有源文件<br>第4行include_directories：包含头文件路径，HEAD_PATH是在根节点文件中定义的<br>第5行set：设置库的生成的路径，LIB_PATH是在根节点文件中定义的<br>第6行add_library：生成静态库，静态库名字CALC_LIB是在根节点文件中定义的</p>
<h4 id="3-2-3-sort-目录"><a href="#3-2-3-sort-目录" class="headerlink" title="3.2.3 sort 目录"></a>3.2.3 sort 目录</h4><p>sort 目录中的 CMakeLists.txt文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(SORTLIB)</span><br><span class="line">aux_source_directory(./ SRC)</span><br><span class="line">include_directories($&#123;HEAD_PATH&#125;)</span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;LIB_PATH&#125;)</span><br><span class="line">add_library($&#123;SORT_LIB&#125; SHARED $&#123;SRC&#125;)</span><br></pre></td></tr></table></figure>

<p>第6行add_library：生成动态库，动态库名字SORT_LIB是在根节点文件中定义的<br>这个文件中的内容和calc节点文件中的内容类似，只不过这次生成的是动态库。</p>
<p>在生成库文件的时候，这个库可以是静态库也可以是动态库，一般需要根据实际情况来确定。如果生成的库比较大，建议将其制作成动态库。</p>
<h4 id="3-2-4-test1-目录"><a href="#3-2-4-test1-目录" class="headerlink" title="3.2.4 test1 目录"></a>3.2.4 test1 目录</h4><p>test1 目录中的 CMakeLists.txt文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCTEST)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">$&#123;CALC_LIB&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_1&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>第4行include_directories：指定头文件路径，HEAD_PATH变量是在根节点文件中定义的<br>第6行link_libraries：指定可执行程序要链接的静态库，CALC_LIB变量是在根节点文件中定义的<br>第7行set：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的<br>第8行add_executable：生成可执行程序，APP_NAME_1变量是在根节点文件中定义的<br>此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了。</p>
<h4 id="3-2-5-test2-目录"><a href="#3-2-5-test2-目录" class="headerlink" title="3.2.5 test2 目录"></a>3.2.5 test2 目录</h4><p>test2 目录中的 CMakeLists.txt文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(SORTTEST)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SORT_LIB&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>第四行include_directories：包含头文件路径，HEAD_PATH变量是在根节点文件中定义的<br>第五行set：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的<br>第六行link_directories：指定可执行程序要链接的动态库的路径，LIB_PATH变量是在根节点文件中定义的<br>第七行add_executable：生成可执行程序，APP_NAME_2变量是在根节点文件中定义的<br>第八行target_link_libraries：指定可执行程序要链接的动态库的名字<br>在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库。</p>
<h4 id="3-2-6-构建项目"><a href="#3-2-6-构建项目" class="headerlink" title="3.2.6 构建项目"></a>3.2.6 构建项目</h4><p>一切准备就绪之后，开始构建项目，进入到根节点目录的build 目录中，执行cmake 命令，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/cmake/calc/build</span><br></pre></td></tr></table></figure>

<p>可以看到在build目录中生成了一些文件和目录，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tree build -L 1     </span><br><span class="line">build</span><br><span class="line">├── calc                  # 目录</span><br><span class="line">├── CMakeCache.txt        # 文件</span><br><span class="line">├── CMakeFiles            # 目录</span><br><span class="line">├── cmake_install.cmake   # 文件</span><br><span class="line">├── Makefile              # 文件</span><br><span class="line">├── sort                  # 目录</span><br><span class="line">├── test1                 # 目录</span><br><span class="line">└── test2                 # 目录</span><br></pre></td></tr></table></figure>

<p>然后在build 目录下执行make 命令:</p>
<p>通过上图可以得到如下信息：</p>
<p>在项目根目录的lib目录中生成了静态库libcalc.a<br>在项目根目录的lib目录中生成了动态库libsort.so<br>在项目根目录的bin目录中生成了可执行程序test1<br>在项目根目录的bin目录中生成了可执行程序test2<br>最后再来看一下上面提到的这些文件是否真的被生成到对应的目录中了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tree bin/ lib/</span><br><span class="line">bin/</span><br><span class="line">├── test1</span><br><span class="line">└── test2</span><br><span class="line">lib/</span><br><span class="line">├── libcalc.a</span><br><span class="line">└── libsort.so</span><br></pre></td></tr></table></figure>

<p>由此可见，真实不虚，至此，项目构建完毕。</p>
<p>写在最后：</p>
<p>在项目中，如果将程序中的某个模块制作成了动态库或者静态库并且在CMakeLists.txt 中指定了库的输出目录，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了，如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用 link_directories 将库文件路径指定出来。</p>
<ol start="2">
<li>流程控制<br>在 CMake 的 CMakeLists.txt 中也可以进行流程控制，也就是说可以像写 shell 脚本那样进行条件判断和循环。</li>
</ol>
<h3 id="3-2条件判断"><a href="#3-2条件判断" class="headerlink" title="3.2条件判断"></a>3.2条件判断</h3><p>关于条件判断其语法格式如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">elseif</span>(&lt;condition&gt;) <span class="comment"># 可选快, 可以重复</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">else</span>()              <span class="comment"># 可选快</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>在进行条件判断的时候，如果有多个条件，那么可以写多个elseif，最后一个条件可以使用else，但是开始和结束是必须要成对出现的，分别为：if和endif。</p>
<h4 id="3-2-1-基本表达式"><a href="#3-2-1-基本表达式" class="headerlink" title="3.2.1 基本表达式"></a>3.2.1 基本表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;expression&gt;)</span><br></pre></td></tr></table></figure>

<p>如果是基本表达式，expression 有以下三种情况：常量、变量、字符串。</p>
<p>如果是1, ON, YES, TRUE, Y, 非零值，非空字符串时，条件判断返回True<br>如果是 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND，空字符串时，条件判断返回False</p>
<h4 id="3-2-2-逻辑判断"><a href="#3-2-2-逻辑判断" class="headerlink" title="3.2.2 逻辑判断"></a>3.2.2 逻辑判断</h4><p><strong>NOT</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(NOT &lt;condition&gt;)</span><br></pre></td></tr></table></figure>


<p>其实这就是一个取反操作，如果条件condition为True将返回False，如果条件condition为False将返回True。</p>
<p><strong>AND</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;cond1&gt; AND &lt;cond2&gt;)</span><br></pre></td></tr></table></figure>


<p>如果cond1和cond2同时为True，返回True否则返回False。</p>
<p><strong>OR</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;cond1&gt; OR &lt;cond2&gt;)</span><br></pre></td></tr></table></figure>

<p>如果cond1和cond2两个条件中至少有一个为True，返回True，如果两个条件都为False则返回False。</p>
<h4 id="3-2-3-比较"><a href="#3-2-3-比较" class="headerlink" title="3.2.3 比较"></a>3.2.3 比较</h4><p>基于数值的比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;variable|string&gt; LESS &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; GREATER &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; EQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; LESS_EQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; GREATER_EQUAL &lt;variable|string&gt;)</span><br></pre></td></tr></table></figure>

<p>LESS：如果左侧数值小于右侧，返回True<br>GREATER：如果左侧数值大于右侧，返回True<br>EQUAL：如果左侧数值等于右侧，返回True<br>LESS_EQUAL：如果左侧数值小于等于右侧，返回True<br>GREATER_EQUAL：如果左侧数值大于等于右侧，返回True<br>基于字符串的比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;variable|string&gt; STRLESS &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STRGREATER &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STREQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STRLESS_EQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STRGREATER_EQUAL &lt;variable|string&gt;)</span><br></pre></td></tr></table></figure>

<p>STRLESS：如果左侧字符串小于右侧，返回True<br>STRGREATER：如果左侧字符串大于右侧，返回True<br>STREQUAL：如果左侧字符串等于右侧，返回True<br>STRLESS_EQUAL：如果左侧字符串小于等于右侧，返回True<br>STRGREATER_EQUAL：如果左侧字符串大于等于右侧，返回True<br>3.2.4 文件操作<br>判断文件或者目录是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(EXISTS path-to-file-or-directory)</span><br></pre></td></tr></table></figure>

<p>如果文件或者目录存在返回True，否则返回False。</p>
<p>判断是不是目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(IS_DIRECTORY path)</span><br></pre></td></tr></table></figure>

<p>此处目录的 path 必须是绝对路径<br>如果目录存在返回True，目录不存在返回False。<br>判断是不是软连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(IS_SYMLINK file-name)</span><br></pre></td></tr></table></figure>

<p>此处的 file-name 对应的路径必须是绝对路径<br>如果软链接存在返回True，软链接不存在返回False。<br>软链接相当于 Windows 里的快捷方式<br>判断是不是绝对路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(IS_ABSOLUTE path)</span><br></pre></td></tr></table></figure>

<p>关于绝对路径:<br>如果是Linux，该路径需要从根目录开始描述<br>如果是Windows，该路径需要从盘符开始描述<br>如果是绝对路径返回True，如果不是绝对路径返回False。<br>3.2.5 其它<br>判断某个元素是否在列表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;variable|string&gt; IN_LIST &lt;variable&gt;)</span><br></pre></td></tr></table></figure>

<p>CMake 版本要求：大于等于3.3<br>如果这个元素在列表中返回True，否则返回False。<br>比较两个路径是否相等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;variable|string&gt; PATH_EQUAL &lt;variable|string&gt;)</span><br></pre></td></tr></table></figure>

<p>CMake 版本要求：大于等于3.24<br>如果这个元素在列表中返回True，否则返回False。<br>关于路径的比较其实就是另个字符串的比较，如果路径格式书写没有问题也可以通过下面这种方式进行比较：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;variable|string&gt; STREQUAL &lt;variable|string&gt;)</span><br></pre></td></tr></table></figure>

<p>我们在书写某个路径的时候，可能由于误操作会多写几个分隔符，比如把&#x2F;a&#x2F;b&#x2F;c写成&#x2F;a&#x2F;&#x2F;b&#x2F;&#x2F;&#x2F;c，此时通过STREQUAL对这两个字符串进行比较肯定是不相等的，但是通过PATH_EQUAL去比较两个路径，得到的结果确实相等的，可以看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.26)</span><br><span class="line">project(test)</span><br><span class="line"></span><br><span class="line">if(&quot;/home//robin///Linux&quot; PATH_EQUAL &quot;/home/robin/Linux&quot;)</span><br><span class="line">    message(&quot;路径相等&quot;)</span><br><span class="line">else()</span><br><span class="line">    message(&quot;路径不相等&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&quot;)</span><br><span class="line"></span><br><span class="line">if(&quot;/home//robin///Linux&quot; STREQUAL &quot;/home/robin/Linux&quot;)</span><br><span class="line">    message(&quot;路径相等&quot;)</span><br><span class="line">else()</span><br><span class="line">    message(&quot;路径不相等&quot;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>


<p>输出的日志信息如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">路径相等</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">路径不相等</span><br></pre></td></tr></table></figure>

<p>通过得到的结果我们可以得到一个结论：在进行路径比较的时候，如果使用 PATH_EQUAL 可以自动剔除路径中多余的分割线然后再进行路径的对比，使用 STREQUAL 则只能进行字符串比较。</p>
<p>关于 if 的更多条件判断，请参考官方文档<br>2.2 循环<br>在 CMake 中循环有两种方式，分别是：foreach和while。</p>
<p>2.2.1 foreach<br>使用 foreach 进行循环，语法格式如下：</p>
<p>CMAKE<br>1<br>2<br>3<br>foreach(<loop_var> <items>)<br>    <commands><br>endforeach()<br>通过foreach我们就可以对items中的数据进行遍历，然后通过loop_var将遍历到的当前的值取出，在取值的时候有以下几种用法：</p>
<p>方法1<br>CMAKE<br>1<br>foreach(<loop_var> RANGE <stop>)<br>RANGE：关键字，表示要遍历范围<br>stop：这是一个正整数，表示范围的结束值，在遍历的时候从 0 开始，最大值为 stop。<br>loop_var：存储每次循环取出的值<br>举例说明：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>


<p>输出的日志信息是这样的：</p>
<p>SHELL<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>$ cmake ..<br>– 当前遍历的值为: 0<br>– 当前遍历的值为: 1<br>– 当前遍历的值为: 2<br>– 当前遍历的值为: 3<br>– 当前遍历的值为: 4<br>– 当前遍历的值为: 5<br>– 当前遍历的值为: 6<br>– 当前遍历的值为: 7<br>– 当前遍历的值为: 8<br>– 当前遍历的值为: 9<br>– 当前遍历的值为: 10<br>– Configuring done<br>– Generating done<br>– Build files have been written to: &#x2F;home&#x2F;robin&#x2F;abc&#x2F;a&#x2F;build<br>再次强调：在对一个整数区间进行遍历的时候，得到的范围是这样的 【0，stop】，右侧是闭区间包含 stop 这个值。</p>
<p>方法2<br>CMAKE<br>1<br>foreach(<loop_var> RANGE <start> <stop> [<step>])<br>这是上面方法1的加强版，我们在遍历一个整数区间的时候，除了可以指定起始范围，还可以指定步长。</p>
<p>RANGE：关键字，表示要遍历范围<br>start：这是一个正整数，表示范围的起始值，也就是说最小值为 start<br>stop：这是一个正整数，表示范围的结束值，也就是说最大值为 stop<br>step：控制每次遍历的时候以怎样的步长增长，默认为1，可以不设置<br>loop_var：存储每次循环取出的值<br>举例说明：</p>
<p>CMAKE<br>1<br>2<br>3<br>4<br>5<br>6<br>cmake_minimum_required(VERSION 3.2)<br>project(test)</p>
<p>foreach(item RANGE 10 30 2)<br>    message(STATUS “当前遍历的值为: ${item}” )<br>endforeach()<br>输出的结果如下:</p>
<p>SHELL<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>$ cmake ..<br>– 当前遍历的值为: 10<br>– 当前遍历的值为: 12<br>– 当前遍历的值为: 14<br>– 当前遍历的值为: 16<br>– 当前遍历的值为: 18<br>– 当前遍历的值为: 20<br>– 当前遍历的值为: 22<br>– 当前遍历的值为: 24<br>– 当前遍历的值为: 26<br>– 当前遍历的值为: 28<br>– 当前遍历的值为: 30<br>– Configuring done<br>– Generating done<br>– Build files have been written to: &#x2F;home&#x2F;robin&#x2F;abc&#x2F;a&#x2F;build<br>再次强调：在使用上面的方式对一个整数区间进行遍历的时候，得到的范围是这样的 【start，stop】，左右两侧都是闭区间，包含 start 和 stop 这两个值，步长 step 默认为1，可以不设置。</p>
<p>方法3<br>CMAKE<br>1<br>foreach(<loop_var> IN [LISTS [<lists>]] [ITEMS [<items>]])<br>这是foreach的另一个变体，通过这种方式我们可以对更加复杂的数据进行遍历，前两种方式只适用于对某个正整数范围内的遍历。</p>
<p>IN：关键字，表示在 xxx 里边</p>
<p>LISTS：关键字，对应的是列表list，通过set、list可以获得</p>
<p>ITEMS：关键字，对应的也是列表</p>
<p>loop_var：存储每次循环取出的值</p>
<p>CMAKE<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>cmake_minimum_required(VERSION 3.2)<br>project(test)</p>
<h1 id="创建-list"><a href="#创建-list" class="headerlink" title="创建 list"></a>创建 list</h1><p>set(WORD a b c d)<br>set(NAME ace sabo luffy)</p>
<h1 id="遍历-list"><a href="#遍历-list" class="headerlink" title="遍历 list"></a>遍历 list</h1><p>foreach(item IN LISTS WORD NAME)<br>    message(STATUS “当前遍历的值为: ${item}” )<br>endforeach()<br>在上面的例子中，创建了两个 list 列表，在遍历的时候对它们两个都进行了遍历（可以根据实际需求选择同时遍历多个或者只遍历一个）。输出的日志信息如下：</p>
<p>SHELL<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>$ cd build&#x2F;<br>$ cmake ..<br>– 当前遍历的值为: a<br>– 当前遍历的值为: b<br>– 当前遍历的值为: c<br>– 当前遍历的值为: d<br>– 当前遍历的值为: ace<br>– 当前遍历的值为: sabo<br>– 当前遍历的值为: luffy<br>– Configuring done<br>– Generating done<br>– Build files have been written to: &#x2F;home&#x2F;robin&#x2F;abc&#x2F;a&#x2F;build<br>一共输出了7个字符串，说明遍历是没有问题的。接下来看另外一种方式：</p>
<p>CMAKE<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>cmake_minimum_required(VERSION 3.2)<br>project(test)</p>
<p>set(WORD a b c “d e f”)<br>set(NAME ace sabo luffy)<br>foreach(item IN ITEMS ${WORD} ${NAME})<br>    message(STATUS “当前遍历的值为: ${item}” )<br>endforeach()<br>在上面的例子中，遍历过程中将关键字LISTS改成了ITEMS，后边跟的还是一个或者多个列表，只不过此时需要通过${}将列表中的值取出。其输出的信息和上一个例子是一样的：</p>
<p>SHELL<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>$ cd build&#x2F;<br>$ cmake ..<br>– 当前遍历的值为: a<br>– 当前遍历的值为: b<br>– 当前遍历的值为: c<br>– 当前遍历的值为: d e f<br>– 当前遍历的值为: ace<br>– 当前遍历的值为: sabo<br>– 当前遍历的值为: luffy<br>– Configuring done<br>– Generating done<br>– Build files have been written to: &#x2F;home&#x2F;robin&#x2F;abc&#x2F;a&#x2F;build<br>小细节：在通过 set 组织列表的时候，如果某个字符串中有空格，可以通过双引号将其包裹起来，具体的操作方法可以参考上面的例子。</p>
<p>方法4<br>注意事项：这种循环方式要求CMake的版本大于等于 3.17。</p>
<p>CMAKE<br>1<br>foreach(<loop_var>… IN ZIP_LISTS <lists>)<br>通过这种方式，遍历的还是一个或多个列表，可以理解为是方式3的加强版。因为通过上面的方式遍历多个列表，但是又想把指定列表中的元素取出来使用是做不到的，在这个加强版中就可以轻松实现。</p>
<p>loop_var：存储每次循环取出的值，可以根据要遍历的列表的数量指定多个变量，用于存储对应的列表当前取出的那个值。<br>如果指定了多个变量名，它们的数量应该和列表的数量相等<br>如果只给出了一个 loop_var，那么它将一系列的 loop_var_N 变量来存储对应列表中的当前项，也就是说 loop_var_0 对应第一个列表，loop_var_1 对应第二个列表，以此类推……<br>如果遍历的多个列表中一个列表较短，当它遍历完成之后将不会再参与后续的遍历（因为其它列表还没有遍历完）。<br>IN：关键字，表示在 xxx 里边<br>ZIP_LISTS：关键字，对应的是列表list，通过set 、list可以获得<br>CMAKE<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>cmake_minimum_required(VERSION 3.17)<br>project(test)</p>
<h1 id="通过list给列表添加数据"><a href="#通过list给列表添加数据" class="headerlink" title="通过list给列表添加数据"></a>通过list给列表添加数据</h1><p>list(APPEND WORD hello world “hello world”)<br>list(APPEND NAME ace sabo luffy zoro sanji)</p>
<h1 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h1><p>foreach(item1 item2 IN ZIP_LISTS WORD NAME)<br>    message(STATUS “当前遍历的值为: item1 &#x3D; ${item1}, item2&#x3D;${item2}” )<br>endforeach()</p>
<p>message(“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”)</p>
<h1 id="遍历列表-1"><a href="#遍历列表-1" class="headerlink" title="遍历列表"></a>遍历列表</h1><p>foreach(item  IN ZIP_LISTS WORD NAME)<br>    message(STATUS “当前遍历的值为: item1 &#x3D; ${item_0}, item2&#x3D;${item_1}” )<br>endforeach()<br>在这个例子中关于列表数据的添加是通过list来实现的。在遍历列表的时候一共使用了两种方式，一种提供了多个变量来存储当前列表中的值，另一种只有一个变量，但是实际取值的时候需要通过变量名_0、变量名_1、变量名_N 的方式来操作，注意事项：第一个列表对应的编号是0，第一个列表对应的编号是0，第一个列表对应的编号是0。</p>
<p>上面的例子输出的结果如下：</p>
<h1 id="SHELL12345678910111213141516-cd-build-cmake-–-当前遍历的值为-item1-hello-item2-ace–-当前遍历的值为-item1-world-item2-sabo–-当前遍历的值为-item1-hello-world-item2-luffy–-当前遍历的值为-item1-item2-zoro–-当前遍历的值为-item1-item2-sanji"><a href="#SHELL12345678910111213141516-cd-build-cmake-–-当前遍历的值为-item1-hello-item2-ace–-当前遍历的值为-item1-world-item2-sabo–-当前遍历的值为-item1-hello-world-item2-luffy–-当前遍历的值为-item1-item2-zoro–-当前遍历的值为-item1-item2-sanji" class="headerlink" title="SHELL12345678910111213141516$ cd build&#x2F;$ cmake ..– 当前遍历的值为: item1 &#x3D; hello, item2&#x3D;ace– 当前遍历的值为: item1 &#x3D; world, item2&#x3D;sabo– 当前遍历的值为: item1 &#x3D; hello world, item2&#x3D;luffy– 当前遍历的值为: item1 &#x3D; , item2&#x3D;zoro– 当前遍历的值为: item1 &#x3D; , item2&#x3D;sanji"></a>SHELL<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>$ cd build&#x2F;<br>$ cmake ..<br>– 当前遍历的值为: item1 &#x3D; hello, item2&#x3D;ace<br>– 当前遍历的值为: item1 &#x3D; world, item2&#x3D;sabo<br>– 当前遍历的值为: item1 &#x3D; hello world, item2&#x3D;luffy<br>– 当前遍历的值为: item1 &#x3D; , item2&#x3D;zoro<br>– 当前遍历的值为: item1 &#x3D; , item2&#x3D;sanji</h1><p>– 当前遍历的值为: item1 &#x3D; hello, item2&#x3D;ace<br>– 当前遍历的值为: item1 &#x3D; world, item2&#x3D;sabo<br>– 当前遍历的值为: item1 &#x3D; hello world, item2&#x3D;luffy<br>– 当前遍历的值为: item1 &#x3D; , item2&#x3D;zoro<br>– 当前遍历的值为: item1 &#x3D; , item2&#x3D;sanji<br>– Configuring done (0.0s)<br>– Generating done (0.0s)<br>– Build files have been written to: &#x2F;home&#x2F;robin&#x2F;abc&#x2F;a&#x2F;build<br>2.2.2 while<br>除了使用foreach也可以使用 while 进行循环，关于循环结束对应的条件判断的书写格式和if&#x2F;elseif 是一样的。while的语法格式如下：</p>
<p>CMAKE<br>1<br>2<br>3<br>while(<condition>)<br>    <commands><br>endwhile()<br>while循环比较简单，只需要指定出循环结束的条件即可：</p>
<p>CMAKE<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>cmake_minimum_required(VERSION 3.5)<br>project(test)</p>
<h1 id="创建一个列表-NAME"><a href="#创建一个列表-NAME" class="headerlink" title="创建一个列表 NAME"></a>创建一个列表 NAME</h1><p>set(NAME luffy sanji zoro nami robin)</p>
<h1 id="得到列表长度"><a href="#得到列表长度" class="headerlink" title="得到列表长度"></a>得到列表长度</h1><p>list(LENGTH NAME LEN)</p>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>while(${LEN} GREATER  0)<br>    message(STATUS “names &#x3D; ${NAME}”)<br>    # 弹出列表头部元素<br>    list(POP_FRONT NAME)<br>    # 更新列表长度<br>    list(LENGTH NAME LEN)<br>endwhile()<br>输出的结果如下:</p>
<p>SHELL<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>$ cd build&#x2F;<br>$ cmake ..<br>– names &#x3D; luffy;sanji;zoro;nami;robin<br>– names &#x3D; sanji;zoro;nami;robin<br>– names &#x3D; zoro;nami;robin<br>– names &#x3D; nami;robin<br>– names &#x3D; robin<br>– Configuring done (0.0s)<br>– Generating done (0.0s)<br>– Build files have been written to: &#x2F;home&#x2F;robin&#x2F;abc&#x2F;a&#x2F;build<br>可以看到当列表中的元素全部被弹出之后，列表的长度变成了0，此时while循环也就退出了。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/LightningJie">GitHub</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CMake%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">CMake学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81CMake%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">一、CMake概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.1.</span> <span class="toc-text">2.1 注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E6%B3%A8%E9%87%8A%E8%A1%8C"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">2.1.1 注释行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E6%B3%A8%E9%87%8A%E5%9D%97"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2.1.2 注释块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8F%AA%E6%9C%89%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.1 只有源文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%85%B1%E5%A4%84%E4%B8%80%E5%AE%A4"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">2.1.1 共处一室</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-VIP-%E5%8C%85%E6%88%BF"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2.1.2 VIP 包房</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%A7%81%E4%BA%BA%E8%AE%A2%E5%88%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">2.2 私人订制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">2.2.1 定义变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8%E7%9A%84C-%E6%A0%87%E5%87%86"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2.2.2 指定使用的C++标准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E6%8C%87%E5%AE%9A%E8%BE%93%E5%87%BA%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">2.2.3 指定输出的路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">2.3 搜索文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E6%96%B9%E5%BC%8F1"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">2.3.1 方式1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E6%96%B9%E5%BC%8F2"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2.3.2 方式2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.5.</span> <span class="toc-text">2.4 包含头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93%E6%88%96%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.1.6.</span> <span class="toc-text">2.5 制作动态库或静态库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">2.5.1 制作静态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">2.5.2 制作动态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E6%8C%87%E5%AE%9A%E8%BE%93%E5%87%BA%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">2.5.3 指定输出的路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%8C%85%E5%90%AB%E5%BA%93%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.7.</span> <span class="toc-text">2.6 包含库文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">2.6.1 链接静态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">2.6.2 链接动态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">2.6.3 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%97%A5%E5%BF%97"><span class="toc-number">1.1.8.</span> <span class="toc-text">2.7 日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.9.</span> <span class="toc-text">2.8 变量操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1-%E8%BF%BD%E5%8A%A0"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">2.8.1 追加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%BB%E9%99%A4"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">2.8.2 字符串移除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.10.</span> <span class="toc-text">2.9 宏定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B5%8C%E5%A5%97%E7%9A%84CMake"><span class="toc-number">1.2.</span> <span class="toc-text">三、嵌套的CMake</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.1 准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">3.1.1 节点关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E6%B7%BB%E5%8A%A0%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">3.1.2 添加子目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2 解决问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">3.2.1 根目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-calc-%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">3.2.2 calc 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-sort-%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3.2.3 sort 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-test1-%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">3.2.4 test1 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-test2-%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">3.2.5 test2 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">3.2.6 构建项目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.2条件判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%9F%BA%E6%9C%AC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">3.2.1 基本表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">3.2.2 逻辑判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.2.3 比较</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-list"><span class="toc-number">2.</span> <span class="toc-text">创建 list</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-list"><span class="toc-number">3.</span> <span class="toc-text">遍历 list</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87list%E7%BB%99%E5%88%97%E8%A1%A8%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">4.</span> <span class="toc-text">通过list给列表添加数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">遍历列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8-1"><span class="toc-number">6.</span> <span class="toc-text">遍历列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SHELL12345678910111213141516-cd-build-cmake-%E2%80%93-%E5%BD%93%E5%89%8D%E9%81%8D%E5%8E%86%E7%9A%84%E5%80%BC%E4%B8%BA-item1-hello-item2-ace%E2%80%93-%E5%BD%93%E5%89%8D%E9%81%8D%E5%8E%86%E7%9A%84%E5%80%BC%E4%B8%BA-item1-world-item2-sabo%E2%80%93-%E5%BD%93%E5%89%8D%E9%81%8D%E5%8E%86%E7%9A%84%E5%80%BC%E4%B8%BA-item1-hello-world-item2-luffy%E2%80%93-%E5%BD%93%E5%89%8D%E9%81%8D%E5%8E%86%E7%9A%84%E5%80%BC%E4%B8%BA-item1-item2-zoro%E2%80%93-%E5%BD%93%E5%89%8D%E9%81%8D%E5%8E%86%E7%9A%84%E5%80%BC%E4%B8%BA-item1-item2-sanji"><span class="toc-number">7.</span> <span class="toc-text">SHELL12345678910111213141516$ cd build&#x2F;$ cmake ..– 当前遍历的值为: item1 &#x3D; hello, item2&#x3D;ace– 当前遍历的值为: item1 &#x3D; world, item2&#x3D;sabo– 当前遍历的值为: item1 &#x3D; hello world, item2&#x3D;luffy– 当前遍历的值为: item1 &#x3D; , item2&#x3D;zoro– 当前遍历的值为: item1 &#x3D; , item2&#x3D;sanji</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8-NAME"><span class="toc-number">8.</span> <span class="toc-text">创建一个列表 NAME</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%97%E5%88%B0%E5%88%97%E8%A1%A8%E9%95%BF%E5%BA%A6"><span class="toc-number">9.</span> <span class="toc-text">得到列表长度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">10.</span> <span class="toc-text">循环</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2025/12/29/c++/cmake/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2025/12/29/c++/cmake/&text=CMake入门"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2025/12/29/c++/cmake/&title=CMake入门"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2025/12/29/c++/cmake/&is_video=false&description=CMake入门"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CMake入门&body=Check out this article: http://example.com/2025/12/29/c++/cmake/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2025/12/29/c++/cmake/&title=CMake入门"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2025/12/29/c++/cmake/&title=CMake入门"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2025/12/29/c++/cmake/&title=CMake入门"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2025/12/29/c++/cmake/&title=CMake入门"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2025/12/29/c++/cmake/&name=CMake入门&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2025/12/29/c++/cmake/&t=CMake入门"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2025-2026
    LightningJie
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/LightningJie">GitHub</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
